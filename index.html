<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>

      rect {
          fill: none;
          pointer-events: all;
      }

      .node {
          fill: #000;
      }

      .link {
          stroke: #999;
      }

    </style>
  </head>
  <body>
    <form id="form">
      <input id="subjects" type="text" required pattern="[QPL][1-9][0-9]*(?:,[QPL][1-9][0-9]*)*" placeholder="L88,L129">
      <input id="predicate" type="text" required pattern="P[1-9][0-9]*" placeholder="P5191">
      <button id="start">Start</button>
    </form>
    <svg></svg>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script>
      const entities = {},
            width = Math.max(window.innerWidth - 200, 200),
            height = Math.max(window.innerHeight - 200, 200);

      let force, svg, nodes, nodesById, links, node, link;

      document.getElementById("form").addEventListener("submit", function(event) {
        const subjectsInput = document.getElementById("subjects"),
              predicateInput = document.getElementById("predicate"),
              subjects = subjectsInput.value.split(","),
              predicate = predicateInput.value;
        start(subjects, predicate);
        event.preventDefault();
      });

      function start(subjects, predicate) {
        force = d3.layout.force()
          .size([width, height])
          .nodes([])
          .linkDistance(70)
          .charge(-600)
          .on("tick", tick);

        svg = d3.select("svg")
            .attr("width", width)
          .attr("height", height);

        reset();

        svg.append("rect")
          .attr("width", width)
          .attr("height", height);

        nodes = force.nodes();
        nodesById = {};
        links = force.links();
        node = svg.selectAll(".node");
        link = svg.selectAll(".link");

        getTriples(
          subjects,
          predicate,
          (s, p, o) => {
            console.log('%s %s %s', s, p, o);
            const source = getNode(s),
                  target = getNode(o);
            links.push({source: source, target: target});
            restart();
          },
          restart
        );
      }

      function reset() {
        svg.selectAll("*").remove();
        for (key in entities) {
          delete entities[key];
        }
      }

      function tick() {
        link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

        node.attr("transform", function(d) { return "translate(" + d.x + ", " + d.y + ")"; });
      }

      function restart() {
        link = link.data(links);

        link.enter().insert("line", ".node")
          .attr("class", "link");

        node = node.data(Object.values(nodes));

        node.enter().append("g")
          .attr("class", "node")
          .call(force.drag);
        node.append("circle")
          .attr("r", 5);
        node.append("text")
          .attr("dx", 12)
          .attr("dy", ".35em")
          .text(function(d) { return getSomeText(d.entityId); });

        force.start();
      }

      function getTriples(subjects, predicate, callbackTriple, callbackDone) {
        getEntities(getNewEntityIds(subjects)).then(response => {
          const nextSubjects = [];
          for (const entityId in response.entities) {
            const entity = response.entities[entityId];
            entities[entityId] = entity;
            if (predicate in entity.claims) {
              for (const statement of entity.claims[predicate]) {
                const object = statement.mainsnak.datavalue.value.id;
                nextSubjects.push(object);
                callbackTriple(entityId, predicate, object);
              }
            }
          }
          if (nextSubjects.length > 0) {
            getTriples(nextSubjects, predicate, callbackTriple, callbackDone);
          } else {
            callbackDone();
          }
        });
      }

      function getNewEntityIds(entityIds) {
        return entityIds.filter(entityId => !(entityId in entities));
      }

      function getEntities(entityIds) {
        const url = 'https://www.wikidata.org/w/api.php?' +
              'action=wbgetentities&' +
              'ids=' + entityIds.join('|') + '&' +
              'origin=*&' +
              'format=json&formatversion=2',
              init = {
                mode: 'cors',
                credentials: 'omit'
              };
        return fetch(url, init).then(response => response.json()).catch(console.error);
      }

      function getSomeText(entityId) {
        if (entityId in entities) {
          const entity = entities[entityId];
          if ('lemmas' in entity) {
            for (const lemma of Object.values(entity.lemmas)) {
              return lemma.value;
            }
          } else if ('labels' in entity) {
            if ('en' in entity.labels) {
              return entity.labels.en.value;
            }
            for (const label of Object.values(entity.labels)) {
              return label.value;
            }
          }
        }
        return ""; // TODO return entityId once the texts are not added to the nodes multiple times
      }

      function getNode(entityId) {
        let node = nodesById[entityId];
        if (typeof node === 'undefined') {
          nodesById[entityId] = node = {
            entityId: entityId,
            x: width / 2,
            y: height / 2
          };
          nodes.push(node);
        }
        return node;
      }

    </script>
  </body>
</html>
